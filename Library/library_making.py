# -*- coding: utf-8 -*-
"""Library making.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12zWblgdvASOIee3CpZYsVHAzxPwdmkcX
"""

#Non dummy headed circular lined list
class Node:
  def __init__(self,e,n,p):
    self.elemenet=e
    self.next=n
    self.prev=p

class circularDList:  #nondummy
  def __init__(self,a):
    self.head=Node(a[0],None,None)
    tail=self.head
    for i in range(1,len(a)):
      n=Node(a[i],None,None)
      tail.next=n
      n.prev=tail
      tail=tail.next
    self.head.prev=tail
    tail.next=self.head

  def forwardprint(self):
    n=self.head.next
    print(self.head.element, end="")
    while n!=self.head:
      print(end=",")
      print(n.element, end="")
      n=n.next
    print(".")

  def backwardPrint(self):
    n=self.head.prev
    print(self.head.prev.element, end="")
    temp=n.prev
    while temp!=n:
      print(end=",")
      print(temp.element, end="")
      temp=temp.prev
    print(".")

  def countNode(self):
    c=0
    n=self.head
    while n.next!=self.head:
      c+=1
      n=n.next
    return c

  def nodeAt(self,idx):
    if (idx<0) or (idx>self.countNode()):
      return None
    else:
     c=0
     head=self.head
     while head.next!=None:
      if c==idx:
       return head
      c=c+1
      head=head.next


  def insert(self,elem,idx):
    if idx==0:
      newN=Node(elem,self.head,tail)
      self.head=newN
      tail.next=newN
      newN.prev=tail
    elif idx>=1 or idx<=(self.countNode-1):
      #next_node=self.nodeAt(idx)
      pre=self.nodeAt(idx-1)
      newNode=Node(elem,pre.next,pre)
      pre.next=newNode
      pre.next.prev=newNode
    elif idx==self.countNode:
      tail=self.nodeAt(self.countNode-1)
      new= Node(elem,self.head,tail)
      self.head.prev=new
      new.prev=tail
      tail.next=new
      self.head=new
    else:
      print("Invalid Index")
      
  def indexOf(self, elem):     # returns the index of the containing the given element.if the element does not exist in the List, return -1.
     c=0
     head=self.head
     while head.next!=None:
     if head.element==elem:
         return c
       head=head.next
       c=c+1
     return -1

  def remove(self,idx):
    if idx<0 or idx>self.countNode()-1:
       return None
    if idx== 0:
       rmv=self.head
       self.head=self.head.next
       val=rmv.element
       self.head.prev=tail
       tail.next=self.head
       rmv=None    #garbage collector
       return val
    elif idx < self.countNode():
       prev = self.nodeAt(idx)
       remv= prev.next.element
       prev.next.next.prev=prev
       prev.next = prev.next.next
       return remv
    else:
       dlt= self.tail.element
       self.tail = self.tail.prev
       self.tail.next=self.head
       return dlt